Решение RMQ с помощью разреженной таблицы
"""""""""""""""""""""""""""""""""""""""""""""

*Разреженная таблица* (англ. sparse table) позволяет решать задачу *online static RMQ* (получение минимума или максимума на отрезке, когда элементы массива не могут изменяться, а запросы поступают последовательно) за :math:`O(1)` на запрос, с предподсчётом за :math:`O(n log(n))` и использованием :math:`O(n log(n)` памяти.

Задача:

Дан массив :math:`A[1…N]` целых чисел. Поступают запросы вида :math:`(l,r)`, для каждого из которых требуется найти минимум среди элементов :math:`A[l],A[l+1],…,A[r]`.


Разреженная таблица
""""""""""""""""""""

Разреженная таблица — двумерная структура данных ST[i][j], для которой выполнено следующее:

:math:`ST[i][j]=min(A[i],A[i+1],…,A[i+2^j−1]),j∈[0…logN]`

Иначе говоря, в этой таблице хранятся минимумы на всех отрезках, длины которых равны степеням двойки. Объём памяти, занимаемый таблицей, равен :math:`O(nlog(n))`, и заполненными являются только те элементы, для которых :math:`i+2^j<=N`

Простой метод построения таблицы заключён в следующем реккурентном соотношении:

.. image:: https://i.imgur.com/eMs3xi4.png

Идемпотентность
""""""""""""""""

Такая простота достигается за счет идемпотентности операции минимум: min(a,a)=a. Это один из ключевых моментов этого метода, так как она позволяет нам корректно считать минимум в области пересечения отрезков.

Пусть ∘ — произвольная бинарная операция, которая удовлетворяет свойствам:

* ассоциативности: :math:`a∘(b∘c)=(a∘b)∘c`

* коммутативности: :math:`a∘b=b∘a`
* идемпотентности: :math:`a∘a=a`.

Утверждение
============

:math:`a_l∘a_{l+1}∘…∘a_r=(a_l∘a_{l+1}∘…∘a_{l+k})∘(a_{r−k}∘a_{r−k+1}∘…∘a_r)` , где :math:`\frac{r - l}{2}⩽k⩽r−l`.



Применение к задаче RMQ
""""""""""""""""""""""""""


Предпосчитаем для длины отрезка :math:`l` величину :math:`⌊log2l⌋`. Для этого введем функцию :math:`fl` (от floor, т.к. логарифм округляется вниз):

.. code-block:: text

	int fl(int len):
	    if len = 1
	        return 0
	    else
	        return fl(floar(len / 2)) + 1

Вычисление :math:`fl[l]` происходит за :math:`O(log(l))`. А так как длина может принимать :math:`N` различных значений, то суммарное время предпосчета составляет :math:`O(nlog(n))`.

Пусть теперь дан запрос (l,r). Заметим, что :math:`min(A[l],A[l+1],…,A[r])=min(ST[l][j],ST[r−2j+1][j])`, где :math:`j=max{ k ∣ 2^k⩽r−l+1}`, то есть логарифм длины запрашиваемого отрезка, округленный вниз. Но эту величину мы уже предпосчитали, поэтому запрос выполняется за :math:`O(1)`.

.. image:: https://neerc.ifmo.ru/wiki/images/7/75/SparseTableRMQ.png

Из выше доказанной теоремы следует, что этот метод работает не только с операцией минимум, но и с любой идемпотентной, ассоциативной и коммутативной операцией. Таким образом мы получаем целый класс задач, решаемых разреженной таблицей.