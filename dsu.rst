СНМ
===
СНМ - система непересекающихся множеств

Эта структура данных предоставляет следующие возможности. Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве. За одну операцию можно:

* join_set(x, y) - объединяет два указанных множества (множество, в котором находится элемент x, и множество, в котором находится элемент y).

* find_set(x, y) - возвращает, в каком множестве находится указанный элемент x.

Построение эффективной структуры данных

Множества элементов мы будем хранить в виде деревьев: одно дерево соответствует одному множеству.
Корень дерева — это представитель (лидер) множества.
При реализации это означает, что мы заводим массив parent, в котором для каждого элемента мы храним ссылку на его предка в дерева.
Для корней деревьев будем считать, что их предок — они сами (т.е. ссылка зацикливается в этом месте).

.. code-block:: text

    int find_set(int v) {
        if (v == p[v])
            return v;
        return find_set(p[v]);
    }

    void join_sets(int a, int b) {
        a = find_set(a);
        b = find_set(b);
        if (a != b)
            p[b] = a;
    }

    int main() {
        ...............
        p.resize(n);
        std::iota(p.begin(), p.end(), 0);
    }

.. attention::
    **find_set()** - O(n)

    Легко построить пример, когда после нескольких объединений множеств получится ситуация, что множество — это дерево, выродившееся в длинную цепочку.

    В результате каждый вызов **find_set()** за длину дерева O(n).

Эвристика сжатия пути
=====================

.. hint::
    **find_set()** - O(log n)
    **join_set()** - O(2 * find_set)
    Она заключается в том, что когда после вызова **find_set(v)** мы найдём искомого лидера p множества, то запомним, что у вершины v и всех пройденных по пути вершин — именно этот лидер p.

    parent[] - теперь это сжатый массив предков, хранит предок предка, предок предка предка, и т.д.

.. code-block:: text

    int find_set(int v) {
        if (v == p[v])
            return v;
        return p[v] = find_set(p[v]);
    }

Эвристика объединения по рангу
==============================

.. hint::
    При выполнении **join_set()** будем присоединять дерево с меньшим рангом к дереву с большим рангом.

.. code-block:: text

    bool join(ll u, ll v) {
        u = get(u);
        v = get(v);
        if (u == v) {
            return false;
        }
        if (r[u] > r[v]) {
            swap(u, v);
        }
        p[u] = v;
        r[v] = max(r[v], r[u] + 1);
        return true;
    }

Объединение эвристик: сжатие пути плюс ранговая эвристика

Окончательный результат таков: при совместном применении эвристик сжатия пути и объединения по рангу время работы на один запрос получается :math:`O (\alpha(n)`.

:math:`\alpha(n)` — обратная функция Аккермана  (n ~ 4, n <= 100 ** 600)


:math:`O(M\log N)` Минимальное остовное дерево. Алгоритм Крускала с системой непересекающихся множеств
======================================================================================================



#. Отсортируем все рёбра по неубыванию веса

#. Затем поместим каждую вершину в своё дерево (т.е. своё множество) - на это уйдёт в сумме :math:`O(N)`

#. Перебираем все рёбра (в порядке сортировки) и для каждого ребра за :math:`O(1)` определяем, принадлежат ли его концы разным деревьям (с помощью двух вызовов **find_set()** за :math:`O(1)`). Наконец, объединение двух деревьев будет осуществляться вызовом **join_set()** - также за :math:`O(1)`.

Итого мы получаем асимптотику :math:`O (M log N + N + M) = O (M log N)`.

.. image:: https://i.imgur.com/gwOyPzW.png

.. code-block:: cpp

    #include <bits/stdc++.h>

    using namespace std;

    typedef long long ll;

    #define INF 1e18

    vector<ll> p, r;

    ll get(ll u) {
        if (p[u] == u)
            return u;
        return p[u] = get(p[u]);
    }

    bool join(ll u, ll v) {
        u = get(u);
        v = get(v);
        if (u == v) {
            return false;
        }
        if (r[u] > r[v]) {
            swap(u, v);
        }
        p[u] = v;
        r[v] = max(r[v], r[u] + 1);
        return true;
    }

    int main() {
        ll n, m, a, b, w;
        cin >> n >> m;
        p.resize(n);
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        r.resize(n);
        vector<pair<ll, pair<ll, ll>>> e(m);
        for (int i = 0; i < m; i++) {
            cin >> a >> b >> w;
            a--, b--;
            e[i] = {w, {a, b}};
        }
        sort(e.begin(), e.end());
        ll ans = 0;
        ll k = 0;
        for (int i = 0; i < m; i++) {
            auto t = join(e[i].second.first, e[i].second.second);
            if (t) {
                ans = e[i].first;
                k++;
            }
            if (k == n - 1) {
                break;
            }
        }
        cout <<  ans;
        return 0;
    }

Алгортим прима
"""""""""""""""

TODO